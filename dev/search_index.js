var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = ProjMPSs","category":"page"},{"location":"#ProjMPSs","page":"Home","title":"ProjMPSs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for ProjMPSs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [ProjMPSs]","category":"page"},{"location":"#ProjMPSs.BlockedMPS","page":"Home","title":"ProjMPSs.BlockedMPS","text":"BlockedMPS is a structure that holds multiple MPSs (ProjMPS) that are associated with different non-overlapping projectors.\n\n\n\n\n\n","category":"type"},{"location":"#ProjMPSs.LazyContraction","page":"Home","title":"ProjMPSs.LazyContraction","text":"Lazy evaluation for contraction of two ProjMPS objects.\n\n\n\n\n\n","category":"type"},{"location":"#ProjMPSs.ProjMPS","page":"Home","title":"ProjMPSs.ProjMPS","text":"An MPS with a projector.\n\n\n\n\n\n","category":"type"},{"location":"#ProjMPSs.Projector","page":"Home","title":"ProjMPSs.Projector","text":"A projector represents a projection of a tensor from a set of its indices to integers. Each index is projected to a positive integer.\n\n\n\n\n\n","category":"type"},{"location":"#ProjMPSs.Projector-Union{Tuple{Pair{ITensors.Index{T}, Int64}}, Tuple{T}} where T","page":"Home","title":"ProjMPSs.Projector","text":"Constructing a projector from a single pair of index and integer.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:&-Tuple{ProjMPSs.Projector, ProjMPSs.Projector}","page":"Home","title":"Base.:&","text":"a & b represents the intersection of the indices that a and b are projected at.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:+-Tuple{ProjMPSs.BlockedMPS, ProjMPSs.BlockedMPS}","page":"Home","title":"Base.:+","text":"Add two BlockedMPS objects.\n\nIf the two projects have the same projectors in the same order, the resulting BlockedMPS will have the same projectors in the same order. By default, we use directsum algorithm to compute the sum and no truncation is performed.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:<-Tuple{ProjMPSs.Projector, ProjMPSs.Projector}","page":"Home","title":"Base.:<","text":"a < b means that a is projected at a subset of the indices that b is projected at.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:|-Tuple{ProjMPSs.Projector, ProjMPSs.Projector}","page":"Home","title":"Base.:|","text":"a | b represents the union of the indices that a and b are projected at.\n\nIf a is projected at inds=1 and b is not projected for the same inds, then a | b is not projected for inds.\n\n\n\n\n\n","category":"method"},{"location":"#Base.getindex-Tuple{ProjMPSs.BlockedMPS, Integer}","page":"Home","title":"Base.getindex","text":"Indexing for BlockedMPS. This is deprecated and will be removed in the future.\n\n\n\n\n\n","category":"method"},{"location":"#Base.isdisjoint-Tuple{AbstractVector{ProjMPSs.Projector}}","page":"Home","title":"Base.isdisjoint","text":"Return if projectors are not overlapping\n\n\n\n\n\n","category":"method"},{"location":"#Base.keys-Tuple{ProjMPSs.BlockedMPS}","page":"Home","title":"Base.keys","text":"Return the keys, i.e., projectors of the BlockedMPS.\n\n\n\n\n\n","category":"method"},{"location":"#Base.length-Tuple{ProjMPSs.BlockedMPS}","page":"Home","title":"Base.length","text":"Get the number of sites in the BlockedMPS\n\n\n\n\n\n","category":"method"},{"location":"#Base.values-Tuple{ProjMPSs.BlockedMPS}","page":"Home","title":"Base.values","text":"Return the values, i.e., ProjMPS of the BlockedMPS.\n\n\n\n\n\n","category":"method"},{"location":"#LinearAlgebra.norm-Tuple{ProjMPSs.BlockedMPS}","page":"Home","title":"LinearAlgebra.norm","text":"Return the norm of the BlockedMPS.\n\n\n\n\n\n","category":"method"},{"location":"#ProjMPSs._add_patching-Tuple{AbstractVector{ProjMPSs.ProjMPS}}","page":"Home","title":"ProjMPSs._add_patching","text":"Add multiple ProjMPS objects on the same projector.\n\nIf the bond dimension of the result reaches maxdim, perform patching recursively to reduce the bond dimension.\n\n\n\n\n\n","category":"method"},{"location":"#ProjMPSs._next_projindex-Tuple{ProjMPSs.Projector, Any}","page":"Home","title":"ProjMPSs._next_projindex","text":"Return the next index to be projected.\n\n\n\n\n\n","category":"method"},{"location":"#ProjMPSs.adaptive_patching-Tuple{ProjMPSs.BlockedMPS, Any}","page":"Home","title":"ProjMPSs.adaptive_patching","text":"Adaptive patching\n\nDo patching recursively to reduce the bond dimension. If the bond dimension of a ProjMPS exceeds maxdim, perform patching.\n\n\n\n\n\n","category":"method"},{"location":"#ProjMPSs.adaptive_patching-Tuple{ProjMPSs.ProjMPS, Any}","page":"Home","title":"ProjMPSs.adaptive_patching","text":"Adaptive patching\n\nDo patching recursively to reduce the bond dimension. If the bond dimension of a ProjMPS exceeds maxdim, perform patching.\n\n\n\n\n\n","category":"method"},{"location":"#ProjMPSs.adaptivecontract","page":"Home","title":"ProjMPSs.adaptivecontract","text":"Perform contruction of two BlockedMPS objects.\n\nThe ProjMPS objects of each BlockedMPS do not overlap with each other. This makes the algorithm much simpler\n\n\n\n\n\n","category":"function"},{"location":"#ProjMPSs.add_patching-Tuple{AbstractVector{ProjMPSs.BlockedMPS}}","page":"Home","title":"ProjMPSs.add_patching","text":"Add multiple BlockedMPS objects.\n\n\n\n\n\n","category":"method"},{"location":"#ProjMPSs.contract-Tuple{ProjMPSs.BlockedMPS, ProjMPSs.BlockedMPS}","page":"Home","title":"ProjMPSs.contract","text":"Contract two Blocked MPS objects.\n\nAt each site, the objects must share at least one site index.\n\n\n\n\n\n","category":"method"},{"location":"#ProjMPSs.projcontract-Tuple{AbstractVector{ProjMPSs.ProjMPS}, AbstractVector{ProjMPSs.ProjMPS}, ProjMPSs.Projector}","page":"Home","title":"ProjMPSs.projcontract","text":"Project two ProjMPS objects to proj before contracting them. The results are summed.\n\n\n\n\n\n","category":"method"},{"location":"#ProjMPSs.projcontract-Tuple{ProjMPSs.ProjMPS, ProjMPSs.ProjMPS, ProjMPSs.Projector}","page":"Home","title":"ProjMPSs.projcontract","text":"Project two ProjMPS objects to proj before contracting them.\n\n\n\n\n\n","category":"method"},{"location":"#ProjMPSs.project-Tuple{ProjMPSs.LazyContraction, ProjMPSs.Projector}","page":"Home","title":"ProjMPSs.project","text":"Project the LazyContraction object to prj before evaluating it.\n\nThis may result in projecting the external indices of a and b.\n\n\n\n\n\n","category":"method"},{"location":"#ProjMPSs.rearrange_siteinds-Tuple{ProjMPSs.BlockedMPS, Any}","page":"Home","title":"ProjMPSs.rearrange_siteinds","text":"Rearrange the site indices of the BlockedMPS according to the given order. If nessecary, tensors are fused or split to match the new order.\n\n\n\n\n\n","category":"method"},{"location":"#ProjMPSs.siteindices-Tuple{ProjMPSs.BlockedMPS}","page":"Home","title":"ProjMPSs.siteindices","text":"Return the site indices of the BlockedMPS. The site indices are returned as a vector of sets, where each set corresponds to the site indices at each site.\n\n\n\n\n\n","category":"method"}]
}
